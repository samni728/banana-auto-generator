# Gemini Auto PPT Generator - 图片下载技术实现原理

> 本文档详细介绍了该扩展如何实现从 Google Gemini 页面批量下载高清图片的技术方案，包括图片检测、按钮定位、网络请求拦截以及文件保存的完整流程。

---

## 📋 目录

1. [整体架构](#1-整体架构)
2. [图片数量检测](#2-图片数量检测)
3. [下载按钮定位](#3-下载按钮定位)
4. [核心技术：webRequest 网络请求拦截](#4-核心技术webrequest-网络请求拦截)
5. [完整下载流程](#5-完整下载流程)
6. [关键技术难点与解决方案](#6-关键技术难点与解决方案)
7. [代码结构说明](#7-代码结构说明)

---

## 1. 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                         Chrome Extension                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌───────────────┐    消息通信    ┌───────────────────────────┐ │
│  │   popup.js    │◄──────────────►│      background.js        │ │
│  │  (用户界面)    │                │  (后台服务 + 网络监听)     │ │
│  └───────────────┘                └───────────────────────────┘ │
│         │                                    ▲                  │
│         │ sendMessage                        │ webRequest API   │
│         ▼                                    │                  │
│  ┌───────────────────────────────────────────┴───────────────┐  │
│  │                     content.js                            │  │
│  │  - 检测页面图片数量                                         │  │
│  │  - 查找 "Download full size" 按钮                         │  │
│  │  - 模拟点击按钮触发下载                                     │  │
│  │  - 等待后台下载确认                                        │  │
│  └───────────────────────────────────────────────────────────┘  │
│                              ▲                                  │
│                              │ DOM 操作                         │
│                              ▼                                  │
└────────────────────[ Gemini 网页 ]──────────────────────────────┘
```

### 1.1 权限配置 (manifest.json)

```json
{
  "permissions": [
    "activeTab",      // 访问当前标签页
    "downloads",      // 下载文件
    "storage",        // 存储任务状态
    "webRequest"      // 核心：拦截网络请求
  ],
  "host_permissions": [
    "https://gemini.google.com/*",           // Gemini 页面
    "https://*.googleusercontent.com/*"       // 图片 CDN
  ]
}
```

---

## 2. 图片数量检测

### 2.1 检测策略

**优先检测下载按钮数量**（更准确），其次回退到检测 `<img>` 标签。

```javascript
// content.js - countExistingImages()
function countExistingImages() {
  // 策略1：优先检查下载按钮数量（最准确，因为核心逻辑基于按钮点击）
  const downloadButtons = findDownloadFullSizeButtons();
  if (downloadButtons.length > 0) {
    return downloadButtons.length;
  }

  // 策略2：检查已记录的成功生成图片
  if (successImages && successImages.length) {
    return successImages.filter((item) => isRasterImageUrl(item.src)).length;
  }

  // 策略3：兜底 - 遍历 DOM 中所有 <img> 标签
  const allImages = Array.from(document.querySelectorAll("img"));
  const validImages = allImages.filter((img) => {
    const src = img.src || "";
    // 过滤条件
    if (!isRasterImageUrl(src)) return false;           // 必须是位图格式
    if (!img.complete || img.naturalWidth === 0) return false; // 必须加载完成
    if (src.includes("nano-banana")) return false;       // 排除 UI 图标
    if (src.includes("profile_photo")) return false;     // 排除头像
    return img.naturalWidth > 200;                       // 尺寸过滤
  });
  return validImages.length;
}
```

### 2.2 有效图片判断

```javascript
// 判断是否为可下载的位图格式（PNG/JPEG）
function isRasterImageUrl(src) {
  if (!src) return false;
  const lower = src.toLowerCase();
  
  // 排除 SVG 矢量图
  if (lower.startsWith("data:image/svg")) return false;
  if (lower.endsWith(".svg")) return false;
  if (lower.includes("image/svg")) return false;
  
  // 允许的格式
  if (lower.startsWith("data:image/png")) return true;
  if (lower.startsWith("data:image/jpeg")) return true;
  if (lower.includes(".png") || lower.includes(".jpg")) return true;
  if (lower.includes("googleusercontent.com")) return true;  // Google CDN
  if (lower.startsWith("blob:")) return true;  // Blob URL
  
  return false;
}
```

---

## 3. 下载按钮定位

### 3.1 多选择器策略

Gemini 页面的"Download full size"按钮可能有多种 HTML 结构，采用**多选择器尝试**策略：

```javascript
// content.js - findDownloadFullSizeButtons()
function findDownloadFullSizeButtons() {
  // 按优先级排列的选择器列表
  const selectors = [
    'button[aria-label*="Download full size"]',        // aria-label 英文
    'button[aria-label*="下载完整尺寸"]',               // aria-label 中文
    'button[data-test-id="download-generated-image-button"]', // 测试ID
    'button[aria-label*="Download"]',                   // 通用下载
    'button[title*="Download full size"]',              // title 属性
    'button[title*="下载完整尺寸"]',
    'mat-icon[fonticon="download"]',                    // Material 图标
    'button:has(mat-icon[fonticon="download"])',        // 包含下载图标的按钮
  ];

  const buttons = [];
  for (const selector of selectors) {
    try {
      const found = Array.from(document.querySelectorAll(selector));
      for (const btn of found) {
        // 如果是 mat-icon，向上找 button 父元素
        let button = btn;
        if (btn.tagName === "MAT-ICON") {
          button = btn.closest("button") || btn.parentElement;
        }

        // 验证按钮文本包含下载关键词
        const text = (
          button.textContent || button.getAttribute("aria-label") || ""
        ).toLowerCase();
        
        if (text.includes("download") || text.includes("下载") ||
            text.includes("full size") || text.includes("完整尺寸")) {
          if (!buttons.includes(button)) {
            buttons.push(button);
          }
        }
      }
      if (buttons.length > 0) break; // 找到即停止
    } catch (e) {
      continue; // 某些选择器（如 :has）可能不支持
    }
  }

  // 按 DOM 顺序排序（从上到下，确保序号正确）
  return buttons.sort((a, b) => {
    const posA = a.getBoundingClientRect().top;
    const posB = b.getBoundingClientRect().top;
    return posA - posB;
  });
}
```

### 3.2 按钮排序的重要性

**为什么要按 DOM 位置排序？**

- Gemini 页面中图片按对话顺序排列（第1张在最上面）
- 下载文件需要按 `page1.png`, `page2.png`... 顺序命名
- 通过 `getBoundingClientRect().top` 获取按钮在视口中的垂直位置
- 排序后确保按钮数组与视觉顺序一致

---

## 4. 核心技术：webRequest 网络请求拦截

### 4.1 为什么需要网络拦截？

**问题背景：**
- Gemini 的"Download full size"按钮点击后，会发起一个到 `googleusercontent.com/rd-gg/` 的网络请求
- 这个请求需要携带正确的 **Cookie** 和 **Referer** 才能获取完整图片
- 直接使用 `fetch()` API 请求同样的 URL 会返回 **HTTP 400 错误**
- 使用 `chrome.downloads.download()` 直接下载也无法携带正确的认证信息

**解决方案：**
- 让用户点击按钮（或程序模拟点击）→ 浏览器发起带完整认证的请求
- 使用 `chrome.webRequest.onBeforeRequest` 拦截这个请求
- 在拦截到请求后，使用 `chrome.downloads.download()` 将其保存为文件

### 4.2 URL 特征分析

```
Google Gemini 图片 URL 结构分析：

普通预览图：
https://lh3.googleusercontent.com/gg/AIJ2gl.../xxx=s800
                                         └─ 尺寸参数 (800px)

高清完整图（点击 "Download full size" 触发）：
https://lh3.googleusercontent.com/rd-gg/AIJ2gl.../xxx=s0-d-I?alr=yes
                                  └─────┴─ 关键特征路径   └─ 原始尺寸参数

需要排除的元数据请求：
https://lh3.googleusercontent.com/rd-gg-dl/AIJ2gl.../xxx=s0-d-I?alr=yes
                                  └────────┴─ 会返回 833 字节的 JSON/HTML，不是图片！
```

### 4.3 webRequest 监听器实现（智能头信息校验版）

**核心改进：** 从 `onBeforeRequest` 升级为 `onHeadersReceived`，实现智能过滤。

```javascript
// background.js - 智能头信息校验监听器
chrome.webRequest.onHeadersReceived.addListener(
  function (details) {
    if (!isSniffing) return;

    // 1. URL 粗筛：必须包含 rd-gg
    if (!details.url.includes("rd-gg")) return;

    // 2. 检查是否已处理过该请求
    if (processedRequestIds.has(details.requestId)) return;

    // 3. 获取响应头信息
    const headers = details.responseHeaders || [];

    // 获取 Content-Length (文件大小)
    const lengthHeader = headers.find(
      (h) => h.name.toLowerCase() === "content-length"
    );
    const contentLength = lengthHeader ? parseInt(lengthHeader.value, 10) : 0;

    // 获取 Content-Type (文件类型)
    const typeHeader = headers.find(
      (h) => h.name.toLowerCase() === "content-type"
    );
    const contentType = typeHeader ? typeHeader.value.toLowerCase() : "";

    // 4. 【关键智能过滤】
    // 条件A: 大小必须超过 50KB（过滤 833 bytes 的元数据）
    // 条件B: 类型必须是图片（image/png, image/jpeg, image/webp）
    const MIN_SIZE = 50000; // 50KB
    const isRealImage =
      contentLength > MIN_SIZE && contentType.startsWith("image/");

    if (isRealImage) {
      // URL 去重检查
      const baseUrl = details.url.split("?")[0];
      if (capturedUrls.has(details.url) || capturedUrls.has(baseUrl)) return;

      // 从队列取出文件名
      const currentFilename = downloadQueue.shift();
      processedRequestIds.add(details.requestId);
      capturedUrls.add(details.url);
      capturedUrls.add(baseUrl);

      console.log(`[BG] 🎯 捕获合格大图 (${(contentLength/1024/1024).toFixed(2)}MB)`);

      // 发起下载
      chrome.downloads.download({
        url: details.url,
        filename: currentFilename,
        conflictAction: "uniquify",
        saveAs: false,
      }, (downloadId) => {
        // 直接通知前台成功
        chrome.tabs.sendMessage(details.tabId, {
          action: "downloadStarted",
          filename: currentFilename,
          downloadId: downloadId,
        });
      });
    } else {
      // 被过滤的请求（元数据/小文件）
      console.log(`[BG] 🗑️ 忽略: ${contentLength} bytes, ${contentType}`);
    }
    return {};
  },
  { urls: ["*://*.googleusercontent.com/*rd-gg*"] },
  ["responseHeaders"] // 需要此权限读取响应头
);
```

### 4.4 为什么改用 onHeadersReceived？

| 监听阶段 | 可获取信息 | 局限性 |
|---------|-----------|--------|
| `onBeforeRequest` | 仅 URL | 无法区分 5MB 图片和 833 字节元数据 |
| `onHeadersReceived` | URL + 响应头 | 可检查 Content-Length 和 Content-Type |

**核心过滤逻辑：**
```javascript
const isRealImage = contentLength > 50000 && contentType.startsWith("image/");
```

这样可以：
- ✅ 过滤掉 833 字节的元数据文件
- ✅ 过滤掉 text/html 或 application/json 响应
- ✅ 只下载真正的大图（> 50KB 且类型为 image/*）

---

## 5. 完整下载流程

```
┌──────────────────────────────────────────────────────────────────────────┐
│                           完整下载流程图                                  │
├──────────────────────────────────────────────────────────────────────────┤

用户点击"下载"按钮
        │
        ▼
┌───────────────────┐
│   content.js      │
│ 1. 查找所有下载按钮│
│ 2. 生成文件名列表  │
│    [dir/page1.png,│
│     dir/page2.png │
│     ...]          │
└─────────┬─────────┘
          │ sendMessage("startSniffing", {filenames})
          ▼
┌───────────────────┐
│  background.js    │
│ 1. isSniffing=true│
│ 2. downloadQueue= │
│    filenames      │
│ 3. capturedUrls   │
│    清空           │
└─────────┬─────────┘
          │ 返回 success
          ▼
┌───────────────────┐
│   content.js      │
│ 开始循环点击按钮   │
└─────────┬─────────┘
          │
          │ for (每个按钮) {
          ▼
┌───────────────────┐
│ 1. 滚动到按钮可见  │
│ 2. 创建 Promise   │
│    等待下载确认    │
│ 3. button.click() │
└─────────┬─────────┘
          │ 按钮点击触发浏览器发起网络请求
          ▼
┌─────────────────────────────────────────────────┐
│ 浏览器发起请求                                   │
│ GET https://...googleusercontent.com/rd-gg/...  │
│ (自动携带 Cookie, Referer)                       │
└─────────┬───────────────────────────────────────┘
          │ webRequest.onBeforeRequest 拦截
          ▼
┌───────────────────┐
│  background.js    │
│ 1. 检查 URL 特征   │
│ 2. 从队列取文件名  │
│ 3. downloads.     │
│    download()     │
│ 4. 发送消息通知   │
│    content.js     │
└─────────┬─────────┘
          │ sendMessage("downloadStarted")
          ▼
┌───────────────────┐
│   content.js      │
│ Promise resolve   │
│ 继续下一个按钮...  │
└─────────┬─────────┘
          │ }
          │
          │ 所有按钮处理完成
          ▼
┌───────────────────┐
│ sendMessage       │
│ ("stopSniffing")  │
│ 清理状态          │
└───────────────────┘
```

### 5.1 content.js 下载主逻辑

```javascript
// content.js - downloadAllGeneratedImages()
async function downloadAllGeneratedImages(expectedCount = null) {
  console.log("[Batch] 🎬 开始使用网络监听模式下载...");
  await sleep(2000); // 确保页面稳定

  // 1. 查找所有下载按钮
  const downloadButtons = findDownloadFullSizeButtons();
  if (downloadButtons.length === 0) {
    console.warn("[Batch] ❌ 未找到下载按钮，回退到兜底模式");
    await downloadAllGeneratedImagesFallback(expectedCount);
    return;
  }

  const totalCount = downloadButtons.length;
  console.log(`[Batch] ✅ 找到 ${totalCount} 个下载按钮`);

  // 2. 生成文件名列表（按顺序）
  const filenames = downloadButtons.map((_, i) => {
    const pageNum = i + 1;
    return saveDirectory
      ? `${saveDirectory}/page${pageNum}.png`
      : `page${pageNum}.png`;
  });

  // 3. 通知后台开始监听
  await chrome.runtime.sendMessage({
    action: "startSniffing",
    filenames: filenames,
  });

  // 4. 初始化等待器 Map
  if (!window.downloadWaiters) {
    window.downloadWaiters = new Map();
  }

  // 5. 依次点击按钮并等待确认
  for (let i = 0; i < downloadButtons.length; i++) {
    const pageNum = i + 1;
    const button = downloadButtons[i];
    const currentFilename = filenames[i];

    // 滚动到按钮可见
    button.scrollIntoView({ behavior: "smooth", block: "center" });
    await sleep(500);

    // 创建 Promise 等待下载确认
    const downloadConfirmed = new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        window.downloadWaiters.delete(currentFilename);
        reject(new Error(`超时 (${pageNum}/${totalCount})`));
      }, 180000); // 3分钟超时

      window.downloadWaiters.set(currentFilename, {
        resolve: (data) => { clearTimeout(timeout); resolve(data); },
        reject: (error) => { clearTimeout(timeout); reject(error); },
        data: { pageNum, totalCount },
      });
    });

    // 点击按钮
    button.click();

    // 等待确认
    try {
      const result = await downloadConfirmed;
      console.log(`[Batch] ✅ 第 ${pageNum} 张下载成功`);
      await sleep(3000); // 等待稳定后继续
    } catch (err) {
      console.error(`[Batch] ❌ 第 ${pageNum} 张下载失败:`, err.message);
      await sleep(2000);
    }
  }

  // 6. 清理
  window.downloadWaiters.clear();
  chrome.runtime.sendMessage({ action: "stopSniffing" });
  console.log(`[Batch] 🎉 下载任务完成`);
}
```

### 5.2 消息监听与 Promise 解析

```javascript
// content.js - 消息监听器（处理后台的下载确认）
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  // 处理下载成功通知
  if (message.action === "downloadStarted") {
    if (window.downloadWaiters && window.downloadWaiters.has(message.filename)) {
      const { resolve, data } = window.downloadWaiters.get(message.filename);
      window.downloadWaiters.delete(message.filename);
      resolve({ ...message, ...data }); // 解析 Promise
    }
  }
  
  // 处理下载失败通知
  if (message.action === "downloadFailed") {
    if (window.downloadWaiters && window.downloadWaiters.has(message.filename)) {
      const { reject } = window.downloadWaiters.get(message.filename);
      window.downloadWaiters.delete(message.filename);
      reject(new Error(`下载失败: ${message.statusCode}`));
    }
  }
});
```

---

## 6. 关键技术难点与解决方案

### 6.1 难点1：图片 URL 认证问题

**问题：** 直接 `fetch()` Gemini 的图片 URL 返回 HTTP 400

**原因：** `googleusercontent.com` 的图片 URL 需要携带正确的 Cookie 和 Referer

**解决方案：** 利用用户点击按钮触发的原生请求（自动携带认证），通过 webRequest 拦截并下载

### 6.2 难点2：区分真实图片和元数据

**问题：** 点击按钮会触发多个请求，包括返回元数据的小文件

**原因：** 某些 `/rd-gg/` 或 `/rd-gg-dl/` 请求返回 833 字节的 JSON/HTML

**解决方案：** 使用 `onHeadersReceived` 检查响应头，进行智能过滤

```javascript
// 从"看脸（URL）"升级为"看内涵（Header）"
const isRealImage = contentLength > 50000 && contentType.startsWith("image/");
```

**双重保险：**
- 大小校验：Content-Length > 50KB
- 类型校验：Content-Type 必须是 image/*

### 6.3 难点3：Gemini 请求延迟

**问题：** Gemini 服务器响应延迟可达 36-123 秒

**影响：** 如果超时时间设置太短，会导致下载失败

**解决方案：** 
- 将超时时间设置为 180 秒（3分钟）
- 即使队列为空也保持监听器开启
- 由 content.js 主动发送 `stopSniffing` 结束监听

### 6.4 难点4：URL 去重问题

**问题：** 同一张图片可能触发多次请求（带不同时间戳参数）

**解决方案：** 双重去重 - 同时检查完整 URL 和去掉查询参数的基础 URL

```javascript
const baseUrl = details.url.split("?")[0];
const isDuplicate = capturedUrls.has(details.url) || capturedUrls.has(baseUrl);
```

### 6.5 难点5：文件名顺序保证

**问题：** 网络请求可能乱序到达

**解决方案：** 使用队列机制，按点击顺序预先定义文件名，每次拦截到请求时从队列头部取出

```javascript
// 开始时
downloadQueue = ["dir/page1.png", "dir/page2.png", ...];

// 拦截到请求时
const currentFilename = downloadQueue.shift(); // 按顺序取出
```

---

## 7. 代码结构说明

```
gemini-auto-ppt-generator/
├── manifest.json      # 扩展配置（权限、脚本声明）
├── popup.html         # 弹出界面 HTML
├── popup.js           # 弹出界面逻辑
├── content.js         # 内容脚本（核心：图片检测、按钮点击、下载协调）
├── background.js      # 后台脚本（核心：webRequest 监听、下载执行）
├── icon*.png          # 扩展图标
└── *.md               # 文档
```

### 7.1 模块职责

| 模块 | 职责 |
|------|------|
| `popup.js` | 用户界面交互、任务启动/停止、进度显示 |
| `content.js` | DOM 操作、图片检测、按钮定位与点击、下载流程协调 |
| `background.js` | webRequest 监听、`chrome.downloads` API 调用、任务状态持久化 |

### 7.2 通信消息类型

| 消息 | 发送方 | 接收方 | 用途 |
|------|--------|--------|------|
| `startSniffing` | content | background | 开启网络监听 |
| `stopSniffing` | content | background | 关闭网络监听 |
| `downloadStarted` | background | content | 通知下载已启动 |
| `downloadFailed` | background | content | 通知下载失败 |
| `checkExistingImages` | popup | content | 查询页面图片数量 |
| `downloadExisting` | popup | content | 触发下载已有图片 |

---

## 📝 总结

本扩展的核心创新点在于利用 **Chrome webRequest API** 拦截浏览器原生请求，解决了以下问题：

1. ✅ **认证问题**：借助浏览器自动携带的 Cookie/Referer
2. ✅ **高清图片**：精准捕获 `/rd-gg/` 路径的完整尺寸图片
3. ✅ **顺序保证**：队列机制确保文件名与图片顺序一致
4. ✅ **稳定性**：长超时 + 延迟容忍 + 去重机制

这种「点击触发 + 请求拦截 + 重定向下载」的模式，可以应用于其他需要绕过前端限制下载资源的场景。

---

*文档版本: v1.0 | 更新日期: 2024-12*

